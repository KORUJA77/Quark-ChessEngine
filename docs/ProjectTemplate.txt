====================
| PROJECT TEMPLATE |
====================
Welcome! This is a chess engine built completely in python as an exercise in
building fully fledged programs. I'll try my very best to make my work clear,
concise and bug-free but bare with me: I'm a complete amateur at this stuff.

PLEASE NOTE: Lots of this text file is written in present tense for things that
currently don't exist. This is for me to read and follow, so treat these sections
as an insight into what is planned.

"You can use an eraser on the drafting table or a sledgehammer on the
construction site" - Frank Lloyd Wright
"Beauty of style and harmony and grace and good rhythm depends on simplicity."
- Plato


TABLE OF CONTENTS
===================
1. Scope
    i.   Introduction
    ii.  Front-end
    iii. Back-end
    iv.  Relationship to other projects
    v.   An example of ASCII board.
2. Features: Now and Future
3. Abstraction: How does it work?
4. Testing/Requirements
5. Performance


SCOPE
=========
The engine has two main parts: the front-end and the back-end. The front-end
handles all of the GUI and user inputs. It is what is 'visible' to the users.
The back-end is the heavy lifting of the program. It handles all of the search-
and-evaluation of the board along with storing all of the information. We will
look into these two sections separately.

FRONT-END
----------
The most obvious part of the front end is the GUI. It is a simple ASCII graphic
that shows where the pieces are on a chess board. If desired, the engine can be
read in a chess notation style instead.

The front end also handles user inputs. The user specifies his/her moves using
algebraic style chess notation into the terminal. It handles everything you
would expect in a chess engine: castling, en passant, pawn push, checks, pins,
illegal moves and much more.

In this engine there is a special type of algebraic notation. This is because it
is clearer and easier to work with while the engine is under development. The
rules for each note is as follows:

    1. The move is prepended with the symbol for the chess piece.
    2. Add the current algebraic position (e.g. 'e6').
    3. If just moving, the current position is followed by the '->' symbol. If
       capturing, the position is instead followed by the 'x' symbol.
    4. Add the final algebraic position.
    5. Castling, check and checkmate notation is consistent.

So as an example, if the King were to move from e1 to f1 the notation for this
move would be "Ke1->f1". Another example, if a pawn moved from e2 to e4 it would
use "e2->e4". As a final example, a knight is capturing a piece on a2 from b1
which has notation "Na2xb1".

BACK-END
---------
The back end is currently under heavy development and is hard to discuss in any
significant detail. Please come back later.

Most of the control of the engine is done by the chessboard. It controls when
the pieces move and if they are allowed to move as well as when to call the
engine to calculate a move. The chess pieces each are an individual type of
class, but have very little control. They mainly store information more then do
any of the heavy lifting of the program.

DEPENDANCY
-----------
On a most basic level there is little dependancy on other modules. The testing
suite only relies on importing default modules while the core library currently
has no dependancy.

ASCII BOARD LAYOUT
-------------------
Until a true GUI is developed, the board is rendered as a ASCII picture. There
are multiple designs being considered. Below are some examples that might make
it into the final game.

Design 1: Letter representation.

+----------+
| rnbqkbnr |
| pppppppp |
| ........ |
| ........ |
| ........ |
| ........ |
| PPPPPPPP |
| RNBQKBNR |
+----------+

Design 2 & 3: ASCII art representation.

  +------------------------+       +-*--b--c--d--*--f--g--*-+
8 |*R *N:*B *Q:*K *B:*N *R:|     8 |[r][n][b][q][k][b][n][r]|
7 |*P:*P *P:*P *P:*P *P:*P |     7 |[p][p][p][p][p][p][p][p]|
6 |   :::   :::   :::   :::|     6 |   :::   :::   :::   :::|
5 |:::   :::   :::   :::   |     5 |:::   :::   :::   :::   |
4 |   :::   :::   :::   :::|     4 |   :::   :::   :::   :::|
3 |:::   :::   :::   :::   |     3 |:::   :::   :::   :::   |
2 | P :P: P :P: P :P: P :P:|     2 |<P><P><P><P><P><P><P><P>|
1 |:R: N :B: Q :K: B :N: R |     1 |<R><N><B><Q><K><B><N><R>|
  +------------------------+   =>  +-*--b--c--d--*--f--g--*-+
    a  b  c  d  e  f  g  h


Design 4: Unicode representation.

8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
6 ║… … … … … … … …
5 ║… … … … … … … …
4 ║… … … … … … … …
3 ║… … ♘ … … … … …
2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
1 ║♖ … ♗ ♕ ♔ ♗ ♘ ♖
——╚═══════════════
—— a b c d e f g h

To start with the board will be rendered with design 1 as it is the simplist to
create.However I like the look of design 2 and 3 the most, purely because it is
large enough to read and contains enough information about the board. If I can
get it to work, design 4 also looks quite nice (albeit a tad small).

FEATURES
==========
Here are the current features along with the future features I wish to
implement in the engine.

CURRENT FEATURES
    - A semi-working chess board.
    - Framework on backline pieces

FUTURE FEATURES (CURRENT WORKS IN PROGRESS)
    - A working user interface.
    - Castling rules.
    - Check and checkmate rules.

POSSIBLE FEATURES
    - A real GUI using packages like pygame. A collection of simple sprites and
    squares, nothing fancy or animated.

ABSTRACTION
===============
The chess program works like so:

Start the program;
Set up the chess board;
Repeat until win/loss/quit:
    Prompt the user for move;
    Process user input and alter the board state;
    Search for possible moves and evaluate positions;
    Pick the best move after X amount of time;
    Alter the board, show new state to the user;
    Loop to first indentented line.

Other things to include here would be ideas about classes and their methods. In
effect you are creating a mind-map of how the program works together.


TESTING/REQUIREMENTS
======================
This is where checklist-like requirements should be noted and fulfilled. These
can be anywhere from f(x)-> y unit tests up to more complex integrated tests or
anything between. Below I've listed some of the requirements that the engine
should fulfil:

BASIC MOVEMENT & RULES:
    [X] All pawns should be able to behave correctly, including moves for en
    passant, capturing, promoting and pawn pushing.
    [X] Each backline piece should obey its own movement rules, like jumping
    over pieces.
    [X] Pins should be identified and should make certain rules illegal.
    [X] Checks should be identified and handled appropriately.
    [X] Checkmates should be identified and handled appropriately.

GUI:
    [X] The board should be legible, with each piece being easily distingushed
    from the others.
    [X] The individual squares should be easily resolved, much like a physical
    board.
    [X] Making a move should update the interface.

BASIC ENGINE CHARACTERISTICS:
    [X] The engine must be able to hold all of the pieces on the board.
    [X] It must be able to make a move and update the board.

SEARCH-AND-EVALUATION:
    [ ] The engine should be able to instantly identify moves where a piece is
    taken "for nothing."
    [ ] The engine should be able to calculate if a one-move exchange is in its
    favour.
    [ ] Eventually, it should be able to also determine the outcome of a chain
    exchange.
    [ ] If there are no obvious moves, it should be able to determine the best
    move that maximises its position.

PERFORMANCE
============
Other than bug testing there should also be performance testing to see where the
software chokes. This section is probably more optional since most programs
created wont be worrying about speed. Anyway, here is an example:

- Compounding interest 1000 times:
    - Via old method  ->  2.113s
    - Via new method  ->  1.566s
    - Using lists     ->  2.778s
    - Using tuples    ->  2.619s
